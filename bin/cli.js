#!/usr/bin/env node

const commander = require("commander");
const chalk = require("chalk");
const validateProjectName = require("validate-npm-package-name");
const fs = require("fs-extra");
const semver = require("semver");

const packageJson = require("./package.json");
const cloneRepo = require("./utils/cloneRepo");
const spawn = require("cross-spawn");
const gitInit = require("./utils/gitInit");

// npx create-react-interface <project-name>

// TODO: Add Yarn support
// TODO: Add PNPM support
// TODO: Add tailwindcss support

let projectName;

function checkAppName(appName) {
	const validationResult = validateProjectName(appName);

	if (!validationResult.validForNewPackages) {
		console.error(
			chalk.red(
				`Cannot create a project named ${chalk.green(
					`"${appName}"`
				)} because of npm naming restrictions:\n`
			)
		);
		[
			...(validationResult.errors || []),
			...(validationResult.warnings || []),
		].forEach((error) => {
			console.error(chalk.red(`  * ${error}`));
		});
		console.error(chalk.red("\nPlease choose a different project name."));
		process.exit(1);
	}

	const dependencies = [
		"babel",
		"rollup",
		"storybook",
		"jest",
		"react",
		"typescript",
	].sort();
	if (dependencies.includes(appName)) {
		console.error(
			chalk.red(
				`Cannot create a project named ${chalk.green(
					`"${appName}"`
				)} because a dependency with the same name exists.\n` +
					`Due to the way npm works, the following names are not allowed:\n\n`
			) +
				chalk.cyan(
					dependencies.map((depName) => `  ${depName}`).join("\n")
				) +
				chalk.red("\n\nPlease choose a different project name.")
		);
		process.exit(1);
	}
}

// If project only contains files generated by GH, itâ€™s safe.
// Also, if project contains remnant error logs from a previous
// installation, lets remove them now.
// We also special case IJ-based products .idea because it integrates with CRA:
// https://github.com/facebook/create-react-app/pull/368#issuecomment-243446094
function isSafeToCreateProjectIn(root, name) {
	const validFiles = [
		".DS_Store",
		".git",
		".gitattributes",
		".gitignore",
		".gitlab-ci.yml",
		".hg",
		".hgcheck",
		".hgignore",
		".idea",
		".npmignore",
		".travis.yml",
		"docs",
		"LICENSE",
		"README.md",
		"mkdocs.yml",
		"Thumbs.db",
	];
	// These files should be allowed to remain on a failed install, but then
	// silently removed during the next create.
	const errorLogFilePatterns = [
		"npm-debug.log",
		"yarn-error.log",
		"yarn-debug.log",
	];
	const isErrorLog = (file) => {
		return errorLogFilePatterns.some((pattern) => file.startsWith(pattern));
	};

	const conflicts = fs
		.readdirSync(root)
		.filter((file) => !validFiles.includes(file))
		// IntelliJ IDEA creates module files before CRA is launched
		.filter((file) => !/\.iml$/.test(file))
		// Don't treat log files from previous installation as conflicts
		.filter((file) => !isErrorLog(file));

	if (conflicts.length > 0) {
		console.log(
			`The directory ${chalk.green(
				name
			)} contains files that could conflict:`
		);
		console.log();
		for (const file of conflicts) {
			try {
				const stats = fs.lstatSync(path.join(root, file));
				if (stats.isDirectory()) {
					console.log(`  ${chalk.blue(`${file}/`)}`);
				} else {
					console.log(`  ${file}`);
				}
			} catch (e) {
				console.log(`  ${file}`);
			}
		}
		console.log();
		console.log(
			"Either try using a new directory name, or remove the files listed above."
		);

		return false;
	}

	// Remove any log files from a previous installation.
	fs.readdirSync(root).forEach((file) => {
		if (isErrorLog(file)) {
			fs.removeSync(path.join(root, file));
		}
	});
	return true;
}

function createProject(name, typescript, tailwind, pnpm) {
	const unsupportedNodeVersion = !semver.satisfies(
		// Coerce strings with metadata (i.e. `15.0.0-nightly`).
		semver.coerce(process.version),
		">=14"
	);

	if (unsupportedNodeVersion) {
		console.log(
			chalk.yellow(
				`You are using Node ${process.version} so the project may install old unsupported version of tools.\n\n` +
					`Please update to Node 14 or higher for a better, fully supported experience.\n`
			)
		);
	}

	const root = path.resolve(name);
	const appName = path.basename(root);

	checkAppName(appName);
	fs.ensureDirSync(name);

	if (!isSafeToCreateProjectIn(root, name)) {
		process.exit(1);
	}

	// Clone template from github
	if (!cloneRepo(appName)) {
		console.log();
		console.log(chalk.red("Error: Cloning of the repository failed."));
		process.exit(1);
	}

	cleanUpPackageJson();

	console.log();
	console.log("Installing Dependencies");
	console.log();

	spawn.sync("npm", ["install"], { cwd: projectName, stdio: "inherit" });

	// Remove bin and other un-needed files/folders
	rimraf.sync(`${projectName}/bin`);
	rimraf.sync(`${projectName}/LICENSE`);

	// Try to initialize new git repository
	if (gitInit(projectName)) {
		console.log();
		console.log("Initialized a git repository.");
	}

	// Done
	console.log();
	console.log(
		chalk.green("Success!"),
		`Created ${projectName} at ${process.cwd()}`
	);
	console.log();

	console.log(chalk.cyan("To start your new library:"));
	console.log();
	if (projectName !== ".") {
		console.log(chalk.cyan(`    cd ${projectName}`));
	}
	console.log(chalk.cyan(`    npm run storybook`));
	console.log();
}

function init() {
	const program = new commander.Command(packageJson.name)
		.version(packageJson.version)
		.arguments("<project-directory>")
		.usage(`${chalk.green("<project-directory>")} [options]`)
		.action((name) => {
			projectName = name;
		})
		.parse(process.argv);

	if (typeof projectName === "undefined") {
		console.error("Please specify the project directory:");
		console.log(
			`  ${chalk.cyan(program.name())} ${chalk.green(
				"<project-directory>"
			)}`
		);
		console.log();
		console.log("For example:");
		console.log(
			`  ${chalk.cyan(program.name())} ${chalk.green(
				"my-component-library"
			)}`
		);
		process.exit(1);
	} else {
		createProject(
			projectName,
			program.typescript,
			program.tailwindcss,
			program.usePnpm
		);
	}
}

init();
